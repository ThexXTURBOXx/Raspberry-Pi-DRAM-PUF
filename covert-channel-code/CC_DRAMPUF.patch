Binary files rpi-open-firmware-master/arm_chainloader/build/arm_chainloader.bin and rpi-open-firmware/arm_chainloader/build/arm_chainloader.bin differ
Binary files rpi-open-firmware-master/arm_chainloader/build/arm_chainloader.bin.elf and rpi-open-firmware/arm_chainloader/build/arm_chainloader.bin.elf differ
Binary files rpi-open-firmware-master/arm_chainloader/build/armv6zk-objects/drivers/cprman.o and rpi-open-firmware/arm_chainloader/build/armv6zk-objects/drivers/cprman.o differ
Binary files rpi-open-firmware-master/arm_chainloader/build/armv6zk-objects/drivers/fatfs/ff.o and rpi-open-firmware/arm_chainloader/build/armv6zk-objects/drivers/fatfs/ff.o differ
Binary files rpi-open-firmware-master/arm_chainloader/build/armv6zk-objects/drivers/libfdt/fdt.o and rpi-open-firmware/arm_chainloader/build/armv6zk-objects/drivers/libfdt/fdt.o differ
Binary files rpi-open-firmware-master/arm_chainloader/build/armv6zk-objects/drivers/libfdt/fdt_ro.o and rpi-open-firmware/arm_chainloader/build/armv6zk-objects/drivers/libfdt/fdt_ro.o differ
Binary files rpi-open-firmware-master/arm_chainloader/build/armv6zk-objects/drivers/libfdt/fdt_rw.o and rpi-open-firmware/arm_chainloader/build/armv6zk-objects/drivers/libfdt/fdt_rw.o differ
Binary files rpi-open-firmware-master/arm_chainloader/build/armv6zk-objects/drivers/libfdt/fdt_strerror.o and rpi-open-firmware/arm_chainloader/build/armv6zk-objects/drivers/libfdt/fdt_strerror.o differ
Binary files rpi-open-firmware-master/arm_chainloader/build/armv6zk-objects/drivers/libfdt/fdt_wip.o and rpi-open-firmware/arm_chainloader/build/armv6zk-objects/drivers/libfdt/fdt_wip.o differ
Binary files rpi-open-firmware-master/arm_chainloader/build/armv6zk-objects/drivers/mailbox.o and rpi-open-firmware/arm_chainloader/build/armv6zk-objects/drivers/mailbox.o differ
Binary files rpi-open-firmware-master/arm_chainloader/build/armv6zk-objects/drivers/mbr_disk.o and rpi-open-firmware/arm_chainloader/build/armv6zk-objects/drivers/mbr_disk.o differ
Binary files rpi-open-firmware-master/arm_chainloader/build/armv6zk-objects/drivers/sdhost_impl.o and rpi-open-firmware/arm_chainloader/build/armv6zk-objects/drivers/sdhost_impl.o differ
Binary files rpi-open-firmware-master/arm_chainloader/build/armv6zk-objects/drivers/uart.o and rpi-open-firmware/arm_chainloader/build/armv6zk-objects/drivers/uart.o differ
Binary files rpi-open-firmware-master/arm_chainloader/build/armv6zk-objects/lib_armv6/arm_bcopy.o and rpi-open-firmware/arm_chainloader/build/armv6zk-objects/lib_armv6/arm_bcopy.o differ
Binary files rpi-open-firmware-master/arm_chainloader/build/armv6zk-objects/lib_armv6/arm_bzero.o and rpi-open-firmware/arm_chainloader/build/armv6zk-objects/lib_armv6/arm_bzero.o differ
Binary files rpi-open-firmware-master/arm_chainloader/build/armv6zk-objects/lib_armv6/arm_locore.o and rpi-open-firmware/arm_chainloader/build/armv6zk-objects/lib_armv6/arm_locore.o differ
Binary files rpi-open-firmware-master/arm_chainloader/build/armv6zk-objects/lib_armv6/arm_memcmp.o and rpi-open-firmware/arm_chainloader/build/armv6zk-objects/lib_armv6/arm_memcmp.o differ
Binary files rpi-open-firmware-master/arm_chainloader/build/armv6zk-objects/lib_armv6/arm_strlen.o and rpi-open-firmware/arm_chainloader/build/armv6zk-objects/lib_armv6/arm_strlen.o differ
Binary files rpi-open-firmware-master/arm_chainloader/build/armv6zk-objects/lib_armv6/string_misc.o and rpi-open-firmware/arm_chainloader/build/armv6zk-objects/lib_armv6/string_misc.o differ
Binary files rpi-open-firmware-master/arm_chainloader/build/armv6zk-objects/loader.o and rpi-open-firmware/arm_chainloader/build/armv6zk-objects/loader.o differ
Binary files rpi-open-firmware-master/arm_chainloader/build/armv6zk-objects/main.o and rpi-open-firmware/arm_chainloader/build/armv6zk-objects/main.o differ
Binary files rpi-open-firmware-master/arm_chainloader/build/armv6zk-objects/start.o and rpi-open-firmware/arm_chainloader/build/armv6zk-objects/start.o differ
Binary files rpi-open-firmware-master/arm_chainloader/build/armv6zk-objects/trap.o and rpi-open-firmware/arm_chainloader/build/armv6zk-objects/trap.o differ
Binary files rpi-open-firmware-master/arm_chainloader/build/lib/cxx_runtime.o and rpi-open-firmware/arm_chainloader/build/lib/cxx_runtime.o differ
Binary files rpi-open-firmware-master/arm_chainloader/build/lib/panic.o and rpi-open-firmware/arm_chainloader/build/lib/panic.o differ
Binary files rpi-open-firmware-master/arm_chainloader/build/lib/tlsf/tlsf.o and rpi-open-firmware/arm_chainloader/build/lib/tlsf/tlsf.o differ
Binary files rpi-open-firmware-master/arm_chainloader/build/lib/udelay.o and rpi-open-firmware/arm_chainloader/build/lib/udelay.o differ
Binary files rpi-open-firmware-master/arm_chainloader/build/lib/xprintf.o and rpi-open-firmware/arm_chainloader/build/lib/xprintf.o differ
diff -uprN rpi-open-firmware-master/arm_chainloader/drivers/uart.c rpi-open-firmware/arm_chainloader/drivers/uart.c
--- rpi-open-firmware-master/arm_chainloader/drivers/uart.c	2019-02-05 04:30:29.000000000 +0800
+++ rpi-open-firmware/arm_chainloader/drivers/uart.c	2018-03-28 19:52:14.000000000 +0800
@@ -9,3 +9,4 @@ void uart_putc(unsigned int ch)
      while(mmio_read32(UART_FR) & 0x20);
      mmio_write32(UART_DR, ch);
 }
+
diff -uprN rpi-open-firmware-master/arm_chainloader/loader.cc rpi-open-firmware/arm_chainloader/loader.cc
--- rpi-open-firmware-master/arm_chainloader/loader.cc	2019-02-05 04:30:29.000000000 +0800
+++ rpi-open-firmware/arm_chainloader/loader.cc	2018-01-21 19:37:46.000000000 +0800
@@ -142,7 +142,7 @@ struct LoaderImpl {
 		uint8_t* zImage = reinterpret_cast<uint8_t*>(KERNEL_LOAD_ADDRESS);
 		linux_t kernel = reinterpret_cast<linux_t>(zImage);
 
-		size_t ksize = read_file("zImage", zImage, false);
+		size_t ksize = read_file("kernel.img", zImage, false);
 		logf("zImage loaded at 0x%X\n", (unsigned int)kernel);
 
 		/* flush the cache */
diff -uprN rpi-open-firmware-master/arm_chainloader/Makefile rpi-open-firmware/arm_chainloader/Makefile
--- rpi-open-firmware-master/arm_chainloader/Makefile	2019-02-05 04:30:29.000000000 +0800
+++ rpi-open-firmware/arm_chainloader/Makefile	2017-04-03 20:28:10.000000000 +0800
@@ -46,7 +46,7 @@ default: $(TARGET_ARM_CHAINLOADER)
 
 OBJ := $(addprefix $(TARGET_BUILD_DIR)/, $(addsuffix .o, $(basename $(SRCS))))
 
-CROSS_COMPILE ?= arm-none-eabi-
+CROSS_COMPILE = arm-none-eabi-
 CC = $(CROSS_COMPILE)gcc
 CXX = $(CROSS_COMPILE)gcc
 AS = $(CC)
diff -uprN rpi-open-firmware-master/arm_monitor.c rpi-open-firmware/arm_monitor.c
--- rpi-open-firmware-master/arm_monitor.c	2019-02-05 04:30:29.000000000 +0800
+++ rpi-open-firmware/arm_monitor.c	2019-03-22 10:19:55.805907433 +0800
@@ -19,17 +19,172 @@ First stage monitor.
 
 #include <lib/runtime.h>
 #include "hardware.h"
+#include "getpuf/PufAddress.h"
+#include "getpuf/GetPuf.c"
 
-/*
- * called from sleh_irq (trap.c)
- */
-void arm_monitor_interrupt() {
-	printf("VPU MBOX rcv: 0x%X, cnf 0x%X\n",
-	       ARM_1_MAIL1_RD,
-	       ARM_1_MAIL1_CNF);
+#define logf(fmt, ...) printf("[SDRAM:%s]: " fmt, __FUNCTION__, ##__VA_ARGS__);
+
+unsigned int addmode, bank, row, col, mode, address, funcloc, dcyfunc, nfreq;
+unsigned int stradd, endadd, initvalue, pufsize, decaytime, cputemp, interval;
+
+int getmode()
+{
+	mode=ARM_1_MAIL1_RD;
+
+	switch (mode)
+	{
+		case  0: printf("\nGet All PUF(bit)\n");
+				 break;
+		case  1: printf("\nGet All PUF(cell)\n");
+				 break;
+		case  2: printf("\nGet All PUF(bitflip)\n");
+				 break;
+		case  3: printf("\nExtract PUF at Intervals\n");
+				 break;
+		default: printf("\nTest DRAM PUF\n");
+				 break;
+	}
+	
+	return mode;
+}
+
+void get_address_mode()
+{
+	addmode=ARM_1_MAIL1_RD;
+	if(addmode==0)
+		printf("\nAddress Mode = BRC\n\n");
+	else
+		printf("\nAddress Mode = RBC\n\n");
+}
+
+void get_func_loc()
+{
+	funcloc=ARM_1_MAIL1_RD;
+	if(funcloc==0)
+		printf("\nFunction run on CPU\n\n");
+	else
+		printf("\nFunction run on GPU\n\n");
+}
+
+void get_dcy_func()
+{
+	dcyfunc=ARM_1_MAIL1_RD;
+
+	switch (dcyfunc)
+	{
+		case  0: printf("\nNo operation\n\n");
+				 break;
+		case  1: printf("\nAdd\n\n");
+				 break;
+		case  2: printf("\nDIV\n\n");
+				 break;
+		default: printf("\nNo operation\n\n");
+				 break;
+	}
+}
+void get_func_freq()
+{
+	nfreq=ARM_1_MAIL1_RD;
+	printf("\nFunction execution interval = %d us\n\n", (nfreq*50));
+}
+
+
+void cpu_code()
+{
+  // uint32_t init_val = 0x12345678;
+	int t=ARM_1_MAIL1_RD;
+	uint32_t addr,size;
+	uint32_t temp[2];
+	// mmio_write32(init_addr,init_val);
+	size = 0x4000000;
+	// read cpu code
+	addr = 0xc0000000;
+	for(int i=0;i<size;i++)
+	{
+	    temp[0] = mmio_read32(addr);
+	    addr = addr + 4;
+	    temp[1] = mmio_read32(addr);
+	    if( temp[0] != temp[1] )
+	    {
+	      printf("addr=0x%08X   val=0x%08X \n", addr-4,temp[0]);
+	      printf("addr=0x%08X   val=0x%08X \n", addr,temp[1]);
+	    }
+	    addr += 4;
+	}
+}
+
+void itvl_start_address()
+{
+	stradd=ARM_1_MAIL1_RD;
+	printf("\nPUF start address = 0x%08X\n\n",stradd);
+}
+
+void itvl_end_address()
+{
+	endadd=ARM_1_MAIL1_RD;
+	printf("\nPUF end address = 0x%08X\n\n",endadd);
+}
+
+void itvl_getitvl()
+{
+	interval=ARM_1_MAIL1_RD;
+	printf("\nRow Interval = 0x%X\n\n",interval);
+}
+
+void itvl_getinitvalue()
+{
+	initvalue=ARM_1_MAIL1_RD;
+	printf("\nPUF init value = 0x%08X\n\n",initvalue);
+}
+
+void itvl_getdecaytime()
+{
+	decaytime=ARM_1_MAIL1_RD;
+	printf("\ndecaytime = %d s\n\n",decaytime);
+	puf_extract_itvl(stradd,endadd,initvalue,decaytime, addmode, funcloc, dcyfunc, nfreq);
+}
+
+void all_start_address()
+{
+	stradd=ARM_1_MAIL1_RD;
+	printf("\nPUF start address = 0x%08X\n\n",stradd);
+}
+
+void all_end_address()
+{
+	endadd=ARM_1_MAIL1_RD;
+	printf("\nPUF end address = 0x%08X\n\n",endadd);
+}
+
+void all_getinitvalue()
+{
+	initvalue=ARM_1_MAIL1_RD;
+	printf("\nPUF init value = 0x%08x\n\n",initvalue);
+}
+
+void all_getdecaytime()
+{
+	decaytime=ARM_1_MAIL1_RD;
+	printf("\ndecaytime = %d s\n\n",decaytime);
+	puf_extract_all(stradd, endadd, initvalue, decaytime, addmode, funcloc, dcyfunc, nfreq);
+}
+
+void ext_getdecaytime()
+{
+	decaytime=ARM_1_MAIL1_RD;
+	printf("\ndecaytime = %d s\n\n",decaytime);
+	puf_extracted(stradd, endadd, initvalue, decaytime, addmode, funcloc, dcyfunc, nfreq);
+}
+
+void brc_getdecaytime()
+{
+	decaytime=ARM_1_MAIL1_RD;
+	printf("\ndecaytime = %d s\n\n",decaytime);
+	puf_extract_brc(stradd, endadd, initvalue, decaytime, addmode, funcloc, dcyfunc, nfreq);
 }
 
-void monitor_start() {
+void monitor_start()
+{
 	printf("Starting IPC monitor ...\n");
 
 	/* enable IRQ */
@@ -37,6 +192,6 @@ void monitor_start() {
 
 	for(;;) {
 		__asm__ __volatile__ ("sleep" :::);
-		printf("sleep interrupted!\n");
+		// printf("sleep interrupted!\n");
 	}
 }
diff -uprN rpi-open-firmware-master/broadcom/hardware_vc4.h rpi-open-firmware/broadcom/hardware_vc4.h
--- rpi-open-firmware-master/broadcom/hardware_vc4.h	2019-02-05 04:30:29.000000000 +0800
+++ rpi-open-firmware/broadcom/hardware_vc4.h	2018-01-30 15:35:18.000000000 +0800
@@ -236,7 +236,7 @@ p31       Unassigned
 //   #define DSI1_BASE_ADDRESS              DSI1_BASE
    #define OTP_BASE_ADDRESS               OTP_BASE
 //   #define CPG_BASE_ADDRESS               CPG_BASE
-//   #define TEMP_SENS_BASE_ADDRESS         TS_BASE
+   // #define TEMP_SENS_BASE_ADDRESS         TS_BASE
 
 
    // cprman Audio APB bridge
Binary files rpi-open-firmware-master/build/bootcode.bin and rpi-open-firmware/build/bootcode.bin differ
Binary files rpi-open-firmware-master/build/bootcode.bin.elf and rpi-open-firmware/build/bootcode.bin.elf differ
Binary files rpi-open-firmware-master/build/vc4-objects/arm_monitor.o and rpi-open-firmware/build/vc4-objects/arm_monitor.o differ
Binary files rpi-open-firmware-master/build/vc4-objects/BCM2708PlatformStartup.o and rpi-open-firmware/build/vc4-objects/BCM2708PlatformStartup.o differ
Binary files rpi-open-firmware-master/build/vc4-objects/drivers/BCM2708ArmControl.o and rpi-open-firmware/build/vc4-objects/drivers/BCM2708ArmControl.o differ
Binary files rpi-open-firmware-master/build/vc4-objects/drivers/BCM2708ClockDomains.o and rpi-open-firmware/build/vc4-objects/drivers/BCM2708ClockDomains.o differ
Binary files rpi-open-firmware-master/build/vc4-objects/drivers/BCM2708Gpio.o and rpi-open-firmware/build/vc4-objects/drivers/BCM2708Gpio.o differ
Binary files rpi-open-firmware-master/build/vc4-objects/drivers/BCM2708PowerManagement.o and rpi-open-firmware/build/vc4-objects/drivers/BCM2708PowerManagement.o differ
Binary files rpi-open-firmware-master/build/vc4-objects/drivers/BCM2708UsbPhy.o and rpi-open-firmware/build/vc4-objects/drivers/BCM2708UsbPhy.o differ
Binary files rpi-open-firmware-master/build/vc4-objects/drivers/IODevice.o and rpi-open-firmware/build/vc4-objects/drivers/IODevice.o differ
Binary files rpi-open-firmware-master/build/vc4-objects/lib/cxx_runtime.o and rpi-open-firmware/build/vc4-objects/lib/cxx_runtime.o differ
Binary files rpi-open-firmware-master/build/vc4-objects/lib/memcpy.o and rpi-open-firmware/build/vc4-objects/lib/memcpy.o differ
Binary files rpi-open-firmware-master/build/vc4-objects/lib/panic.o and rpi-open-firmware/build/vc4-objects/lib/panic.o differ
Binary files rpi-open-firmware-master/build/vc4-objects/lib/udelay.o and rpi-open-firmware/build/vc4-objects/lib/udelay.o differ
Binary files rpi-open-firmware-master/build/vc4-objects/lib/xprintf.o and rpi-open-firmware/build/vc4-objects/lib/xprintf.o differ
Binary files rpi-open-firmware-master/build/vc4-objects/romstage.o and rpi-open-firmware/build/vc4-objects/romstage.o differ
Binary files rpi-open-firmware-master/build/vc4-objects/sdram.o and rpi-open-firmware/build/vc4-objects/sdram.o differ
Binary files rpi-open-firmware-master/build/vc4-objects/start.o and rpi-open-firmware/build/vc4-objects/start.o differ
Binary files rpi-open-firmware-master/build/vc4-objects/trap.o and rpi-open-firmware/build/vc4-objects/trap.o differ
diff -uprN rpi-open-firmware-master/getpuf/function.c rpi-open-firmware/getpuf/function.c
--- rpi-open-firmware-master/getpuf/function.c	1970-01-01 08:00:00.000000000 +0800
+++ rpi-open-firmware/getpuf/function.c	2019-03-21 15:39:24.926188135 +0800
@@ -0,0 +1,48 @@
+#include <lib/runtime.h>
+#include "hardware.h"
+#include "PufAddress.h"
+
+
+
+static void multi(uint32_t a, uint32_t b)
+{
+
+    for(int i=0; i<1000000; i++)
+    {
+      uint32_t c=a*b;
+    }
+}
+
+static void add(uint32_t a, uint32_t b)
+{
+
+    for(int i=0; i<1000000; i++)
+    {
+      uint32_t c=a+b;
+    }
+}
+
+static void sub(uint32_t a, uint32_t b)
+{
+
+    for(int i=0; i<1000000; i++)
+    {
+      uint32_t c=a-b;
+    }
+}
+
+static void division(uint32_t a,uint32_t b)
+{
+    for(int i=0; i<1000000; i++)
+    {
+      uint32_t c=a/b;
+    }
+}
+
+static void modulo(uint32_t a,uint32_t b)
+{
+    for(int i=0; i<1000000; i++)
+    {
+      uint32_t c=a%b;
+    }
+}
diff -uprN rpi-open-firmware-master/getpuf/GetPuf.c rpi-open-firmware/getpuf/GetPuf.c
--- rpi-open-firmware-master/getpuf/GetPuf.c	1970-01-01 08:00:00.000000000 +0800
+++ rpi-open-firmware/getpuf/GetPuf.c	2019-03-21 15:45:52.529720430 +0800
@@ -0,0 +1,542 @@
+#include <lib/runtime.h>
+#include "hardware.h"
+#include "PufAddress.h"
+#include "function.c"
+
+extern void timing_init();
+
+#define logf(fmt, ...) printf("[SDRAM:%s]: " fmt, __FUNCTION__, ##__VA_ARGS__);
+
+/**
+ * Descrpition: Manually refresh address segments stored with code
+ * during the decay time
+ *
+ * Input: decay_time
+**/
+static unsigned long MRList[]={
+	0xc0023000,
+	0xc0024000,
+	0xc0123000,
+	0xc0172000,
+	0xc2000000,
+	0xc2001000,
+
+};
+
+int inArray(unsigned long a)
+{
+	int length = sizeof(MRList)/4;
+	for (int i=0; i<length; i++)
+	{
+		if(a==MRList[i])
+			return 1;
+	}
+	return 0;
+}
+
+static void GPUfunc(int dcy_func)
+{
+	switch(dcy_func)
+	{
+		case  1: add(0x200, 0x400);
+				 break;
+		case  2: division(0x200,0x400);
+				 break;
+		default: break;
+	}
+}
+static void Refresh()
+{
+	int length=sizeof(MRList)/4;
+	unsigned long temp=0xc0000000;
+	unsigned int t;
+	for(int j=0;j<15;j++)
+	{
+		t=mmio_read32(temp);
+		temp=temp+0x1000;
+	}
+
+	for(int k=0 ;k<length ;k++)
+	{
+		unsigned long mr=MRList[k];
+		t=mmio_read32(mr);
+	}
+	temp=0xc2002000;
+	for(int i=0;i<=3;i++)
+	{
+		t=mmio_read32(temp);
+		temp=temp+0x1000;
+	}
+
+	temp=0xcf000000;
+	for(int j=0;j<=3;j++)
+	{
+		t=mmio_read32(temp);
+		temp=temp+0x1000;
+	}
+}
+
+
+static void ManuallyRefresh(int decay_time,int dcy_func,int nfreq)
+{	
+	int freq_func=nfreq;			// func_freq=n*50us
+	int ftp=0;
+	int mtp=0;
+	uint32_t ufunc_t=0;
+	int function_count=0;
+	if(dcy_func!=0)
+	{
+		for(int tp=0;tp<=decay_time*20000;)
+		{
+			if(freq_func==0)
+			{
+				while(1)
+				{
+					__asm__ __volatile__ ("nop" :::);
+					uint32_t tin=ST_CLO;
+					
+					GPUfunc(dcy_func);
+					ufunc_t=ST_CLO-tin;
+					uint32_t func_t=ufunc_t/50;
+					function_count+=1;
+					mtp+=func_t;
+					tp+=func_t;
+					if(mtp>=1280)
+					{
+						Refresh();
+						mtp=0;
+					}
+					if(tp>decay_time*20000)
+						break;
+				}
+			}
+			else
+			{
+				ftp+=1;
+				mtp+=1;
+				tp+=1;
+				udelay(50);
+				if(ftp==freq_func)
+				{
+					__asm__ __volatile__ ("nop" :::);
+					uint32_t tin=ST_CLO;
+					
+					GPUfunc(dcy_func);
+					ufunc_t=ST_CLO-tin;
+					uint32_t func_t=ufunc_t/50;
+					function_count+=1;
+					ftp=0;
+					tp+=func_t;
+					mtp+=func_t;
+					if(mtp>=1280)
+					{
+						Refresh();
+						mtp=0;
+					}
+				}
+				if(mtp>=1280)
+				{
+					Refresh();
+					mtp=0;
+				}
+			}
+		}
+	}
+	else
+	{
+		for(int tp=0;tp<=decay_time*1000;)
+		{
+			delay_ms(1);
+			tp+=1;
+			if(tp%64==0)
+			{
+				Refresh();
+			}
+		}
+	}
+	
+	
+	if(function_count!=0)
+	{
+		printf("function_count = %d\n",function_count );
+		printf("function time = %d us\n",ufunc_t);
+	}
+	
+	printf("Manually refresh");
+}
+
+/**
+ * Description: Calculates the number of 1s in an unsigned long integer
+ * > https://www.everything2.com/index.pl?node_id=1181258
+ *
+ * Input: x
+ *
+ * Return: The number of 1
+**/
+unsigned long cal(unsigned long x)
+{
+    unsigned long n;
+    for(n=0; x; n++)
+        x &= x-1;
+    return n;
+}
+
+/**
+ * Description: Write the initial value of puf 
+ * to the specified address segment
+ * 
+ * Input: puf_addr, puf_size, puf_init_value
+**/
+static void puf_init(unsigned long addr,unsigned int puf_size, unsigned int init_value)
+{
+	for(unsigned int puf_write_loop=0;puf_write_loop<puf_size;puf_write_loop++)
+	{
+		if ((addr>=0xc3000000&&addr<0xcf000000)||(addr>=0xd0000000&&addr<0xdf000000))
+		{
+			if(inArray(addr))
+				addr+=0x1000;
+			else
+			{
+				mmio_write32(addr,init_value);
+				addr=addr+4;
+			}
+		}
+	}
+	printf("puf init complete\n");
+}
+
+/**
+ * Description: Write the initial value of puf 
+ * to the specified address segment
+ * 
+ * Input: start_addr, end_addr, puf_init_value
+**/
+static void puf_init_all(unsigned long start_addr, unsigned long end_addr, unsigned int init_value)
+{
+	unsigned long addr;
+	for(addr=start_addr; addr<=end_addr; addr+=4)
+	{
+		if ((addr>=0xc3000000&&addr<=0xcf000000)||(addr>=0xd0000000&&addr<0xe0000000))
+		{
+			if(inArray(addr))
+				addr+=0x1000;
+			else
+			{
+				mmio_write32(addr,init_value);
+			}
+		}
+	}
+}
+
+/**
+ * Description: Read the value of puf to 
+ * the specified address segment
+ * 
+ * Input: start_addr, end_addr, itvl
+ *
+**/
+static void puf_read_itvl(unsigned long start_addr, unsigned long end_addr, unsigned int add_mode)
+{
+	unsigned long itvl=(end_addr-start_addr)/0x1000000;
+
+	unsigned int puf_read_val=0;
+	unsigned long puf_cell=0;
+	unsigned long addr;
+	for (int i = 0; ; i++)
+	{
+		addr=start_addr+i*itvl*0x1000;
+
+	    if(addr >= end_addr)
+	    	break;
+		else if((addr>=0xc3000000&&addr<0xcf000000)||(addr>=0xd0000000&&addr<0xe0000000))
+		{
+			for(unsigned int j=0; j<1024; j++)
+			{
+				unsigned long bank, row, col;
+			    if(add_mode==0)
+				{
+					bank=(0x1c000000&addr)>>26;				//calculate the number of bank
+				    row=(0x03fff000&addr)>>12;				//calculate the number of row
+				    col=(0x00000ffc&addr)>>2;				//calculate the number of column
+				}
+				else
+				{
+					row=(0x1fff8000&addr)>>15;				//28:15
+				    bank=(0x00007000&addr)>>12;				//14:12
+				    col=(0x00000ffc&addr)>>2;				//calculate the number of column
+				}
+
+
+				/* calculate the number of bit-flip in one cell */
+				puf_read_val=mmio_read32(addr);
+				unsigned int sum_flip=cal(puf_read_val);
+				if(sum_flip!=0)
+				{
+					puf_cell+=sum_flip;
+					printf("log= %d, %04X, %03X, %08X\n", bank, row, col, puf_read_val);
+				}
+				addr=addr+4;
+			}
+
+		}
+	}
+	while(1)
+	{
+		printf("puf_cell=%d\n",puf_cell);
+		delay_ms(100);
+
+	}
+}
+
+/**
+ * Description: Read the value of puf of one cell to 
+ * the specified address segment
+ * 
+ * Input: puf_addr
+ *
+**/
+static void puf_read_all(unsigned long start_addr, unsigned long end_addr, unsigned int add_mode)
+{
+	unsigned int puf_read_val=0;
+	unsigned long addr;
+	unsigned long puf_cell=0;
+	for (addr=start_addr;addr<end_addr;addr+=4)
+	{
+		unsigned long bank, row, col;
+		if(addr >= end_addr)
+	    	break;
+		else if((addr>=0xc3000000&&addr<0xcf000000)||(addr>=0xd0000000&&addr<0xe0000000))
+		{
+		    if(add_mode==0)
+			{
+				bank=(0x1c000000&addr)>>26;				//calculate the number of bank
+			    row=(0x03fff000&addr)>>12;				//calculate the number of row
+			    col=(0x00000ffc&addr)>>2;					//calculate the number of column
+			}
+			else
+			{
+				row=(0x1fff8000&addr)>>15;				//28:15
+			    bank=(0x00007000&addr)>>12;				//14:12
+			    col=(0x00000ffc&addr)>>2;					//calculate the number of column
+			}
+
+
+			/* calculate the number of bit-flip in one cell */
+			puf_read_val=mmio_read32(addr);
+			unsigned int sum_flip=cal(puf_read_val);
+			if(sum_flip!=0)
+			{
+				puf_cell++;
+				printf("log= %d, %04X, %03X, %08X\n", bank, row, col, puf_read_val);
+			}
+
+		}
+	}
+	while(1)
+	{
+		printf("puf_cell=%d\n",puf_cell);
+		delay_ms(100);
+
+	}
+}
+/**
+ * Description: Read the value of puf of one cell to 
+ * the specified address segment
+ * 
+ * Input: puf_addr
+ *
+**/
+static void puf_read_ext(unsigned long start_addr, unsigned long end_addr, unsigned int add_mode)
+{
+	unsigned int puf_read_val=0;
+	unsigned long addr;
+	unsigned long puf_cell=0;
+	for (addr=start_addr;addr<end_addr;addr+=4)
+	{
+		unsigned long bank, row, col;
+	    if(add_mode==0)
+		{
+			bank=(0x1c000000&addr)>>26;				//calculate the number of bank
+		    row=(0x03fff000&addr)>>12;				//calculate the number of row
+		    col=(0x00000ffc&addr)>>2;					//calculate the number of column
+		}
+		else
+		{
+			row=(0x1fff8000&addr)>>15;				//28:15
+		    bank=(0x00007000&addr)>>12;				//14:12
+		    col=(0x00000ffc&addr)>>2;					//calculate the number of column
+		}
+		/* calculate the number of bit-flip in one cell */
+		puf_read_val=mmio_read32(addr);
+		unsigned int sum_flip=cal(puf_read_val);
+		if(sum_flip!=0)
+		{
+			puf_cell++;
+			printf("b=%d, r=%04X, c=%03X  ",bank ,row ,col);
+			printf("bitflip=%04d\n",sum_flip);
+		}
+	}
+	while(1)
+	{
+		printf("puf_cell=%d\n",puf_cell);
+		delay_ms(100);
+
+	}
+}
+
+/**
+ * Description: Read the value of puf of one cell to 
+ * the specified address segment
+ * 
+ * Input: puf_addr
+ *
+**/
+static void puf_read_brc(unsigned long start_addr, unsigned long end_addr)
+{
+	unsigned int puf_read_val=0;
+	unsigned long addr;
+	unsigned long sum_flip=0;
+	unsigned long puf_cell=0;
+
+	for (addr=start_addr;addr<end_addr;addr+=4)
+	{
+		/* calculate the number of bit-flip in one cell */
+		puf_read_val=mmio_read32(addr);
+		unsigned int bit_flip=cal(puf_read_val);
+		if(bit_flip!=0)
+		{
+			puf_cell++;
+			sum_flip+=bit_flip;
+		}
+		
+	}
+	while(1)
+	{
+		printf("puf_cell=%d\n",puf_cell);
+		delay_ms(100);
+
+	}
+	printf("total bitflip = %d \n",sum_flip );
+}
+
+/** 
+ * Function: Test puf of contiguous address segment (return puf value)
+ *
+ * Input: puf_start_address, puf_end address, puf_init_value, decay_time
+**/
+static void puf_extract_all(unsigned long start_addr,unsigned long end_addr, unsigned long puf_init_value, int decay_time, int add_mode, int func_loc, int dcy_func, int nfreq)
+{
+	/* PUF Init */
+	puf_init_all(start_addr,end_addr,puf_init_value);
+	printf("puf init complete\n");
+
+	/* Decay & Manually Refresh */ 
+	// printf("SD_SA:value=0x%08X--address=0x%08X\n",SD_SA,&(SD_SA));
+	printf("disable Refresh\n");
+	SD_SA = 0x00003395;
+	// printf("SD_SA:value=0x%08X--address=0x%08X\n",SD_SA,&(SD_SA));
+	if(func_loc)
+		ManuallyRefresh(decay_time, dcy_func, nfreq);
+	else
+		ManuallyRefresh(decay_time, 0, 0);
+	printf("decay completed\n");
+
+	/* Enable Refresh */
+	timing_init();
+
+	/* PUF Read */
+	puf_read_all(start_addr, end_addr, add_mode);
+}
+
+/** 
+ * Function: Test puf of contiguous address segment (return bitflip of one cell)
+ *
+ * Input: puf_start_address, puf_end address, puf_init_value, decay_time
+**/
+static void puf_extracted(unsigned long start_addr,unsigned long end_addr, unsigned long puf_init_value, int decay_time, int add_mode, int func_loc, int dcy_func, int nfreq)
+{
+	/* PUF Init */
+	puf_init_all(start_addr,end_addr,puf_init_value);
+	printf("puf init complete\n");
+
+	/* Decay & Manually Refresh */ 
+	// printf("SD_SA:value=0x%08X--address=0x%08X\n",SD_SA,&(SD_SA));
+	printf("disable Refresh\n");
+	SD_SA = 0x00003395;
+	// printf("SD_SA:value=0x%08X--address=0x%08X\n",SD_SA,&(SD_SA));
+	if(func_loc)
+		ManuallyRefresh(decay_time, dcy_func, nfreq);
+	else
+		ManuallyRefresh(decay_time, 0, 0);
+	printf("decay completed\n");
+
+	/* Enable Refresh */
+	timing_init();
+
+	/* PUF Read */
+	puf_read_ext(start_addr, end_addr, add_mode);
+
+}
+
+/** 
+ * Function: Test puf of contiguous address segment (return total bitflip)
+ *
+ * Input: puf_start_address, puf_end address, puf_init_value, decay_time
+**/
+static void puf_extract_brc(unsigned long start_addr,unsigned long end_addr, unsigned long puf_init_value, int decay_time, int add_mode, int func_loc, int dcy_func, int nfreq)
+{
+
+	/* PUF Init */
+	puf_init_all(start_addr,end_addr,puf_init_value);
+	printf("puf init complete\n");
+
+	/* Decay & Manually Refresh */ 
+	// printf("SD_SA:value=0x%08X--address=0x%08X\n",SD_SA,&(SD_SA));
+	printf("disable Refresh\n");
+	SD_SA = 0x00003395;
+	// printf("SD_SA:value=0x%08X--address=0x%08X\n",SD_SA,&(SD_SA));
+	if(func_loc)
+		ManuallyRefresh(decay_time, dcy_func, nfreq);
+	else
+		ManuallyRefresh(decay_time, 0, 0);
+	printf("decay completed\n");
+
+	/* Enable Refresh */
+	timing_init();
+
+	/* PUF Read */
+	puf_read_brc(start_addr, end_addr);
+
+}
+
+/** 
+ * Function: Test puf at interval
+ *
+ * Input: puf_start_address, puf_end_address, puf_extract_interval, puf_init_value, decay_time
+ *
+ * P.S. Test one row for each interval
+**/
+static void puf_extract_itvl(unsigned long start_addr,unsigned long end_addr, unsigned long puf_init_value,int decay_time, int add_mode, int func_loc, int dcy_func, int nfreq)
+{
+	/* PUF Init */
+	puf_init_all(start_addr,end_addr,puf_init_value);
+	printf("puf init complete\n");
+
+	/* Decay & Manually Refresh */
+	// printf("SD_SA:value=0x%08X--address=0x%08X\n",SD_SA,&(SD_SA));
+	printf("disable Refresh\n");
+	SD_SA = 0x00003395;
+	// printf("SD_SA:value=0x%08X--address=0x%08X\n",SD_SA,&(SD_SA));
+	if(func_loc)
+		ManuallyRefresh(decay_time, dcy_func, nfreq);
+	else
+		ManuallyRefresh(decay_time, 0, 0);
+	printf("decay completed\n");
+
+	/* Enable Refresh */
+	timing_init();
+
+	/* PUF Read (on GPU)*/
+	// puf_read_itvl(start_addr, end_addr, add_mode);
+}
+
diff -uprN rpi-open-firmware-master/getpuf/PufAddress.h rpi-open-firmware/getpuf/PufAddress.h
--- rpi-open-firmware-master/getpuf/PufAddress.h	1970-01-01 08:00:00.000000000 +0800
+++ rpi-open-firmware/getpuf/PufAddress.h	2018-04-09 16:32:02.000000000 +0800
@@ -0,0 +1,22 @@
+#define HIGH_BITS_SET							  0xc0000000
+#define BANK_BITS 								  28:26
+#define BANK_SET                                  0x00000000
+#define BANK_MSB                                  28
+#define BANK_LSB                                  26
+#define BANK_RBC_LSB							  15
+#define ROW_BITS 								  25:12
+#define ROW_SET                                   0x00000000
+#define ROW_MSB                                   25
+#define ROW_LSB                                   12
+#define COL_BITS 								  11:2
+#define COL_SET                                   0x00000000
+#define COL_MSB                                   11
+#define COL_LSB                                   2
+#define HIGH_BITS_ADD							  0x00000000
+
+#define GPIO_BASE 0x7e200000 // for raspi2 & 3 0x20200000 for raspi1
+#define LED_GPFSEL 4
+#define LED_GPFBIT 21
+#define LED_GPCLR 11
+#define LED_GPIO_BIT 15
+#define LED_GPSET 8
\ No newline at end of file
diff -uprN rpi-open-firmware-master/.gitignore rpi-open-firmware/.gitignore
--- rpi-open-firmware-master/.gitignore	1970-01-01 08:00:00.000000000 +0800
+++ rpi-open-firmware/.gitignore	2018-01-24 10:48:15.000000000 +0800
@@ -0,0 +1,2 @@
+build/
+arm_chainloader/build/
diff -uprN rpi-open-firmware-master/hardware.h rpi-open-firmware/hardware.h
--- rpi-open-firmware-master/hardware.h	2019-02-05 04:30:29.000000000 +0800
+++ rpi-open-firmware/hardware.h	2018-01-22 19:35:39.000000000 +0800
@@ -21,7 +21,7 @@ that are missing from the release. This
 #pragma once
 
 #define VC4_PERIPH_BASE 0x7E000000
-#define ARM_PERIPH_BASE 0x3F000000
+#define ARM_PERIPH_BASE 0x20000000
 
 #define VC4_TO_ARM_PERIPH(addr) ((addr - VC4_PERIPH_BASE) + ARM_PERIPH_BASE)
 
diff -uprN rpi-open-firmware-master/lib/runtime.h rpi-open-firmware/lib/runtime.h
--- rpi-open-firmware-master/lib/runtime.h	2019-02-05 04:30:29.000000000 +0800
+++ rpi-open-firmware/lib/runtime.h	2018-04-04 23:37:20.000000000 +0800
@@ -26,6 +26,8 @@ extern "C" {
 #define RegToRef(x) reinterpret_cast<volatile uint32_t*>(&x)
 
 extern void udelay(uint32_t time);
+extern void delay_s(uint32_t t);
+extern void delay_ms(uint32_t t);
 extern void __cxx_init();
 
 #ifdef __VIDEOCORE4__
diff -uprN rpi-open-firmware-master/lib/udelay.c rpi-open-firmware/lib/udelay.c
--- rpi-open-firmware-master/lib/udelay.c	2019-02-05 04:30:29.000000000 +0800
+++ rpi-open-firmware/lib/udelay.c	2018-01-24 09:54:23.000000000 +0800
@@ -25,7 +25,30 @@ void udelay(uint32_t t) {
 	for (;;) {
 		/* nop still takes a cycle i think? */
 		__asm__ __volatile__ ("nop" :::);
+		// if ((ST_CLO - tv) > t)
 		if ((ST_CLO - tv) > t)
 			return;
 	}
+}
+
+void delay_s(uint32_t t) {
+	uint32_t tv = ST_CLO;
+	for (;;) {
+		/* nop still takes a cycle i think? */
+		__asm__ __volatile__ ("nop" :::);
+		// if ((ST_CLO - tv) > t)
+		if ((ST_CLO - tv) > (t*1000000))
+			return;
+	}
+}
+
+void delay_ms(uint32_t t) {
+	uint32_t tv = ST_CLO;
+	for (;;) {
+		/* nop still takes a cycle i think? */
+		__asm__ __volatile__ ("nop" :::);
+		// if ((ST_CLO - tv) > t)
+		if ((ST_CLO - tv) > (t*1000))
+			return;
+	}
 }
\ No newline at end of file
diff -uprN rpi-open-firmware-master/Makefile rpi-open-firmware/Makefile
--- rpi-open-firmware-master/Makefile	2019-02-05 04:30:29.000000000 +0800
+++ rpi-open-firmware/Makefile	2018-04-09 19:53:46.000000000 +0800
@@ -24,6 +24,7 @@ SRCS = \
 	drivers/BCM2708Gpio.cc \
 	BCM2708PlatformStartup.cc
 
+
 ARCH = vc4
 
 BUILD_DIR = build
@@ -42,7 +43,7 @@ default: $(TARGET_BOOTCODE)
 OBJ := $(addprefix $(TARGET_BUILD_DIR)/, $(addsuffix .o, $(basename $(SRCS))))
 
 # the cross compiler should already be in your path
-CROSS_COMPILE ?= vc4-elf-
+CROSS_COMPILE = vc4-elf-
 CC = $(CROSS_COMPILE)gcc
 CXX = $(CROSS_COMPILE)g++
 AS = $(CC)
diff -uprN rpi-open-firmware-master/README.md rpi-open-firmware/README.md
--- rpi-open-firmware-master/README.md	2019-02-05 04:30:29.000000000 +0800
+++ rpi-open-firmware/README.md	2017-04-03 20:28:10.000000000 +0800
@@ -8,15 +8,9 @@ Technical discussion occurs in `#raspber
 
 All Broadcom headers are licensed under 3-Clause BSD License while our code is under GPLv2+. See `LICENSE` for more information. Various external projects are mirrored under a mix of GPL-compatible licenses.
 
-## Is this project dead or abandoned?
-
-It's not dead and not abandoned in a conventional sense. 
-
-However, it is on an indefinite hold. I wrote a detailed explanation [in issue #37](https://github.com/christinaa/rpi-open-firmware/issues/37) of its current situation. 
-
 ## Building
 
-As a prerequisite, Julian Brown's [VC4 toolchain](https://github.com/itszor/vc4-toolchain) is necessary as well as the `arm-none-eabi-` toolchain (Debian package `gcc-arm-none-eabi`). You can tweak the VC4 toolchain path in `CROSS_COMPILE` in `Makefile` and the ARM path in `arm_chainloader/Makefile` if necessary. Contributors should not commit their personal paths. After configuration, run `buildall.sh`. The binary is at `build/bootcode.bin`, ready to be copied to an SD card.
+As a prerequisite, Julian Brown's [VC4 toolchain](https://github.com/puppeh/vc4-toolchain) is necessary as well as the `arm-none-eabi-` toolchain (Debian package `gcc-arm-none-eabi`). You can tweak the VC4 toolchain path in `CROSS_COMPILE` in `Makefile` and the ARM path in `arm_chainloader/Makefile` if necessary. Contributors should not commit their personal paths. After configuration, run `buildall.sh`. The binary is at `build/bootcode.bin`, ready to be copied to an SD card.
 
 ### Building on macOS
 
@@ -33,7 +27,7 @@ Yes, with some conditions. You can boot
 
 ## Thanks To
  * **[Herman Hermitage](https://github.com/hermanhermitage)** for his VC4 documentation and for helping determine suitable ARM PLL configurations.
- * **[Julian Brown](https://github.com/itszor)** for reviewing the code and for his awesome VC4 toolchain.
+ * **[Julian Brown](https://github.com/puppeh)** for reviewing the code and for his awesome VC4 toolchain.
  * **[Alyssa Rosenzweig](https://github.com/bobbybee)** for her contributions to the firmware especially in areas of Linux bringup and early ARM side initialization, as well as fixing mailbox support.
  * **[David Given](https://github.com/davidgiven)** for his initial LLVM project used as the base for the initial LLVM toolchain before moving to GCC.
  * **[Scott Mansell](https://github.com/phire)** for reviewing the code.
diff -uprN rpi-open-firmware-master/sdram.c rpi-open-firmware/sdram.c
--- rpi-open-firmware-master/sdram.c	2019-02-05 04:30:29.000000000 +0800
+++ rpi-open-firmware/sdram.c	2018-03-03 15:46:18.000000000 +0800
@@ -198,7 +198,7 @@ lpddr2_timings_t g_InitSdramParameters =
 	.tINIT5 = 3990, //Max DAI: 3990* (1.0 / 400) = 9.9us ~ 10us
 	/* SB */
 	.rowbits = 2,
-	.colbits = 1,
+	.colbits = 2,
 	.banklow = 2
 };
 
@@ -220,7 +220,7 @@ void reset_with_timing(lpddr2_timings_t*
 	SIP_DEBUG(logf("SDRAM clock disabled!\n"));
 
 	/*
-	 * Migrate over to master PLL.
+	 * Migrate over to master PLL.迁移到主PLL。
 	 */
 
 	APHY_CSR_DDR_PLL_PWRDWN = 0;
@@ -233,7 +233,7 @@ void reset_with_timing(lpddr2_timings_t*
 	APHY_CSR_DDR_PLL_MDIV_VALUE = 0;
 
 	APHY_CSR_DDR_PLL_GLOBAL_RESET = 1;
-
+	// printf("APHY_CSR_DDR_PLL_LOCK_STATUS:value=0x%08X--address=0x%08X\n",APHY_CSR_DDR_PLL_LOCK_STATUS,&(APHY_CSR_DDR_PLL_LOCK_STATUS));
 	SIP_DEBUG(logf("waiting for master ddr pll to lock ...\n"));
 	for (;;) if (APHY_CSR_DDR_PLL_LOCK_STATUS & (1 << 16)) break;
 	SIP_DEBUG(logf("master ddr pll locked!\n"));
@@ -491,6 +491,70 @@ static void selftest() {
 
 #undef RT_ASSERT
 
+static void puf_extracted()
+{
+	unsigned int addr,puf_write_loop, puf_write_value ;
+	addr=0xc2002000;
+	//puf init -- write 0x00000000
+	puf_write_loop=0;
+	for(puf_write_loop=0;puf_write_loop<1024;puf_write_loop++)
+	{
+		// write_mr(addr,0x00011111,true);
+		mmio_write32(addr,0);
+		puf_write_value=mmio_read32(addr);
+		// printf("address=%X-----------puf_value=%X\n",addr,puf_write_value);
+		addr=addr+4;
+	}
+	printf("puf init complete\n");
+	//disable Refresh
+	printf("SD_SA:value=0x%08X--address=0x%08X\n",SD_SA,&(SD_SA));
+	SD_SA =
+	    (0 << SD_SA_RFSH_T_LSB)
+	    | SD_SA_PGEHLDE_SET
+	    | SD_SA_CLKSTOP_SET
+	    | SD_SA_POWSAVE_SET
+	    | 0x3214;
+	printf("disable Refresh\n");
+	printf("SD_SA:value=0x%08X--address=0x%08X\n",SD_SA,&(SD_SA));
+	//decay 150000000
+	delay_s(150);
+	printf("decay completed\n");
+	//enable Refresh
+	SD_SA =
+	    (3113 << SD_SA_RFSH_T_LSB)
+	    | SD_SA_PGEHLDE_SET
+	    | SD_SA_CLKSTOP_SET
+	    | SD_SA_POWSAVE_SET
+	    | 0x3214;
+	//read puf
+	unsigned int addrr,puf_read_loop, puf_read_val;
+	puf_read_val=0;
+	addrr=0xc2002000;
+	for(puf_read_loop=0;puf_read_loop<1024;puf_read_loop++)
+	{
+		puf_read_val=mmio_read32(addrr);
+		printf("address=%X-----------puf_value=%X\n",addrr,puf_read_val);
+		addrr=addrr+4;
+	}
+	
+}
+
+void timing_init()
+{
+	if (g_RAMSize == RAM_SIZE_1GB) {
+		g_InitSdramParameters.colbits = 3;
+		g_InitSdramParameters.rowbits = 3;
+		g_InitSdramParameters.banklow = 3;
+	} else if (g_RAMSize == RAM_SIZE_512MB) {
+		g_InitSdramParameters.colbits = 2;
+	}
+
+	reset_with_timing(&g_InitSdramParameters);
+	init_late();
+	// puf_extracted();
+	selftest();
+}
+
 void sdram_init() {
 	uint32_t vendor_id, bc;
 
@@ -576,5 +640,6 @@ void sdram_init() {
 
 	reset_with_timing(&g_InitSdramParameters);
 	init_late();
+	// puf_extracted();
 	selftest();
 }
diff -uprN rpi-open-firmware-master/trap.c rpi-open-firmware/trap.c
--- rpi-open-firmware-master/trap.c	2019-02-05 04:30:29.000000000 +0800
+++ rpi-open-firmware/trap.c	2018-08-13 10:36:02.000000000 +0800
@@ -99,18 +99,159 @@ void sleh_fatal(vc4_saved_state_t* pcb,
 	hang_cpu();
 }
 
-extern void arm_monitor_interrupt();
+extern int getmode();
+extern void get_func_loc();
+extern void get_dcy_func();
+extern void get_func_freq();
 
-void sleh_irq(vc4_saved_state_t* pcb, uint32_t tp) {
+extern void get_address_mode();
+extern void ext_getdecaytime();
+extern void brc_getdecaytime();
+
+extern void all_start_address();
+extern void all_end_address();
+extern void all_getinitvalue();
+extern void all_getdecaytime();
+
+extern void itvl_start_address();
+extern void itvl_end_address();
+extern void itvl_getitvl();
+extern void itvl_getinitvalue();
+extern void itvl_getdecaytime();
+
+extern void cpu_code();
+
+int time=0;
+/**
+ * flag_m: Mark workmode_set_status
+ * flag_mm: Mark puf_extract_status
+**/
+bool flag_m=0,flag_mm=0;
+int mode=0;
+void sleh_irq(vc4_saved_state_t* pcb, uint32_t tp) 
+{
 	uint32_t status = IC0_S;
 	uint32_t source = status & 0xFF;
+	if (flag_m==0)
+	{
+		mode=getmode();
+	}
 
-	printf("VPU Received interrupt from source %d\n", source);
+	else if (mode==0 && flag_m==1 && flag_mm==0)
+	{
+		time++;
+		switch (time%8)
+		{
+			case  1: get_address_mode();
+					 break;
+			case  2: get_func_loc();
+					 break;
+			case  3: all_start_address();
+					 break;
+			case  4: all_end_address();
+					 break;
+			case  5: all_getinitvalue();
+					 break;
+			case  6: get_dcy_func();
+					 break;
+			case  7: get_func_freq();
+					 break;
+			case  0: all_getdecaytime();
+					 flag_mm=1;
+					 time=0;
+					 break;
+			default: break;
+		}	
+	}
+	
+	else if (mode==1 && flag_m==1 && flag_mm==0) 
+	{
+		time++;
+		switch (time%8)
+		{
+			case  1: get_address_mode();
+					 break;
+			case  2: get_func_loc();
+					 break;
+			case  3: all_start_address();
+					 break;
+			case  4: all_end_address();
+					 break;
+			case  5: all_getinitvalue();
+					 break;
+			case  6: get_dcy_func();
+					 break;
+			case  7: get_func_freq();
+					 break;
+			case  0: ext_getdecaytime();
+					 flag_mm=1;
+					 time=0;
+					 break;
+			default: break;
+		}	
+	} 
+	else if (mode==2 && flag_m==1 && flag_mm==0)
+	{
+		time++;
+		switch (time%8)
+		{
+			case  1: get_address_mode();
+					 break;
+			case  2: get_func_loc();
+					 break;
+			case  3: all_start_address();
+					 break;
+			case  4: all_end_address();
+					 break;
+			case  5: all_getinitvalue();
+					 break;
+			case  6: get_dcy_func();
+					 break;
+			case  7: get_func_freq();
+					 break;
+			case  0: brc_getdecaytime();
+					 flag_mm=1;
+					 time=0;
+					 break;
+			default: break;
+		}	
+	}
+	else if (mode==3 && flag_m==1 && flag_mm==0)
+	{
+		time++;
+		switch (time%8)
+		{
+			case  1: get_address_mode();
+					 break;
+			case  2: get_func_loc();
+					 break;
+			case  3: itvl_start_address();
+					 break;
+			case  4: itvl_end_address();
+					 break;
+			case  5: itvl_getinitvalue();
+					 break;
+			case  6: get_dcy_func();
+					 break;
+			case  7: get_func_freq();
+					 break;
+			case  0: itvl_getdecaytime();
+					 flag_mm=1;
+					 time=0;
+					 break;
+			default: break;
+		}
+	}
+	else if (mode==4)
+	{
+		cpu_code();
+	}
 
-	if (source == INTERRUPT_ARM) {
-		arm_monitor_interrupt();
-	} else {
-		print_vpu_state(pcb);
-		panic("unknown interrupt source!");
+	if(flag_mm==1)
+	{
+		flag_m=0;
+		flag_mm=0;
 	}
-}
+	else
+		flag_m=1;
+}
\ No newline at end of file
